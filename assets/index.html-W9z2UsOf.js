import{_ as n,o as s,c as a,a as e}from"./app-Gvjph52V.js";const t="/images/middleware.png",p={},c=e(`<h1 id="可扩展表现" tabindex="-1"><a class="header-anchor" href="#可扩展表现" aria-hidden="true">#</a> 可扩展表现</h1><p>Nest.js 的可扩展性表现在多个方面，比如：模块化架构、依赖注入、中间件和拦截器、微服务支持等。有点懵？没关系，我们一个个来分析 🧐</p><h2 id="模块化架构" tabindex="-1"><a class="header-anchor" href="#模块化架构" aria-hidden="true">#</a> 模块化架构</h2><p>如果把 Nest.js 比作火箭，那么模块就是火箭的各个部分，比如：发动机、推进器、回收舱等。这样，你可以像搭积木一样，单独修改或添加模块，而不会影响整个火箭的飞行。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>src
├── <span class="token operator">...</span>
├── app<span class="token punctuation">.</span>module<span class="token punctuation">.</span>ts
├── modules
├────── rocket<span class="token operator">/</span>
├────── engine<span class="token operator">/</span>
├────── <span class="token comment">// ... 其他模块</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面就是 Nest.js 模块化架构的简单示例，将整个应用程序分成多个模块，每个模块都专注于特定的任务。如果你还想让火箭支持载人功能，那只需要添加一个新的房间模块，比如：<code>capsule</code></p><h2 id="依赖注入" tabindex="-1"><a class="header-anchor" href="#依赖注入" aria-hidden="true">#</a> 依赖注入</h2><p>类似于火箭需要不同的燃料和润滑剂，Nest.js 使用依赖注入来管理组件之间的关系。这使得你能够像给火箭引擎添加燃料一样，轻松地管理组件之间的依赖。</p><p>听起来是不是有点抽象？🤔️</p><p>实际上，依赖注入的核心理念是解耦组件的依赖关系。这意味着它从组件内部获取依赖项，而不是在组件内部直接创建或实例化它们。通过这种方式，组件无需担心依赖项的创建和生命周期管理，而是通过依赖注入容器自动解析和提供所需的依赖项。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>@<span class="token function">Injectable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">RrocketService</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> engine<span class="token punctuation">;</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">engine</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>engine <span class="token operator">=</span> engine<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 使用 this.engine 进行操作</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面就是依赖注入的一个简单示例，通过 <code>@Injectable()</code> 装饰器，Nest.js 会将 <code>Engine</code> 注入到 <code>RrocketService</code> 中。开发者无需直接实例化 <code>Engine</code>，而是通过依赖注入容器来提供。</p><p>如果还是不明白依赖注入为什么可以增强 Nest.js 的可扩展性的话，好吧，我们举个例子 🌰</p><p><strong>星际飞船的维护</strong>： 假设你是星际飞船的首席设计师，星际飞船有多个系统，比如引擎、能源控制、生命支持等。每个系统都是一个组件，而星际飞船就是一个巨大的模块。</p><p><strong>传统开发方式：</strong>：在没有依赖注入的情况下，你可能会在每个系统内部创建或实例化它所依赖的其他系统。比如，在引擎系统内部，你需要直接实例化能源控制系统：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Engine</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>energyControl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EnergyControl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 直接创建依赖项</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样的问题在于，如果你想添加一个新的系统，比如防御系统，你就需要修改引擎的代码并在其中加入防御系统的实例化。这样一来，系统之间的关系就会变得紧密，代码也变得难以维护和扩展。</p><p><strong>使用依赖注入</strong>：现在，假设你使用依赖注入。每个系统不再负责自己依赖项的实例化，而是通过依赖注入容器来提供。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>@<span class="token function">Injectable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">Engine</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>energyControl<span class="token punctuation">;</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">energyControl</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>energyControl <span class="token operator">=</span> energyControl<span class="token punctuation">;</span> <span class="token comment">// 通过依赖注入容器提供依赖项</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你想添加防御系统，只需在依赖注入容器中注册防御系统，而无需修改引擎的代码。这使得系统之间的耦合度降低，每个系统变得更加独立，更容易被替换或添加。</p><h2 id="中间件和拦截器" tabindex="-1"><a class="header-anchor" href="#中间件和拦截器" aria-hidden="true">#</a> 中间件和拦截器</h2><p>Nest.js 提供了中间件和拦截器的机制，使得在请求的处理过程中可以插入自定义的逻辑。中间件和拦截器可以用于实现诸如权限验证、日志记录、缓存等功能。通过这些机制，你可以在应用程序的不同层面上进行扩展，而不必改变核心的业务逻辑。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Injectable<span class="token punctuation">,</span> NestMiddleware <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;@nestjs/common&#39;</span><span class="token punctuation">;</span>

@<span class="token function">Injectable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AuthMiddleware</span> <span class="token keyword">implements</span> <span class="token class-name">NestMiddleware</span> <span class="token punctuation">{</span>
  <span class="token function">use</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在这里编写身份验证逻辑</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>req<span class="token punctuation">.</span>headers<span class="token punctuation">.</span>authorization<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果请求头中没有授权信息，则返回未经授权的响应</span>
      res<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">&#39;Unauthorized&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 如果身份验证通过，则继续请求处理</span>
    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述例子展示了一个中间件的实现，它会在请求处理过程中验证请求头中的授权信息。若请求头中缺少授权信息，将返回未经授权的响应；反之，若身份验证通过，则继续请求处理。这与前端的路由守卫有着类似的概念，让你能够在不同层面上灵活地扩展应用程序的功能。</p><p><img src="`+t+'" alt=""></p><h2 id="微服务集成" tabindex="-1"><a class="header-anchor" href="#微服务集成" aria-hidden="true">#</a> 微服务集成</h2><p>Nest.js 在构建可扩展应用程序时提供了强大的微服务集成能力。通过微服务，你可以将应用程序拆分成独立的服务，使得它们可以独立开发、部署和维护。这种模块化的架构为应对不断变化的需求提供了灵活性。</p><p>// TODO</p>',28),i=[c];function o(l,u){return s(),a("div",null,i)}const d=n(p,[["render",o],["__file","index.html.vue"]]);export{d as default};
